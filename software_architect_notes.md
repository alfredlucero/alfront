# Software Architect Notes

## What is a Software Architect?

Types of Architects

- Infrastructure Architect
  - Design infrastructure i.e. servers, vms, network, storage, etc.
  - Familiar with requirements
  - Career path: infrastructure expert
- Software Architect
  - Developer knows what can be done
  - Architect knows what should be done
  - Figures out how to meet these common baseline requirements:
    - Fast
    - Secure
    - Reliable
    - Easy to maintain
  - Org chart
    - junior architect may be within a project under project manager
    - senior architect may report directly to CIO/CTO outside of a specific project to handle things across the whole organization
    - certifications geared towards Enterprise Architect
  - Career path: main factor is experience
    - 3 years experience, more common in small companies
    - dev to team leader to jr. architect
    - dev to team leader to dev manager/CTO to senior architect (can become enterprise architect)
    - system analyst to architect but lacks technical experience and requires mentoring
- Enterprise Architect
  - Works with top level management i.e. CEO, CIO
  - Streamlines IT to support business
  - No development-oriented tasks
  - Career Path: Senior Software Architect / Project Manager

Architect's Mindset

- Understand the business
  - Weaknesses
  - Strengths
  - Competition
  - Growth Strategy
- System's Goals
  - Not "what the system should do" or requirements
  - Goals describe the effect on the organization (bottom line, big picture)
  - Usually described by client but exceptions
  - Example 1: Product-oriented company wants to streamline recruitment process in its HR system
  - Example 2: Improve police's response time, attract new residents for reporting and mapping criminal incidents system for large city
  - Example 3: Mobile flash sales for young and small startup, wants to generate quick revenue stream and attract investors
- Your Client's Clients (end users)
  - Possibly show errors or have backend caching if systems go down to provide best experience to users
- Always keep in mind what is the thing that really matters to the person you are talking to
  - Project manager cares primarily on project success (be careful with how you speak about new technology)
  - Team leader cares about programming (can use technical language)
  - CEO cares about the financial bottom line, can avoid technical buzzwords
  - Show how your work contributes to the other person's primary interests

Architecture Process

- Understand the system's requirements after setting the goals
  - Requirements = what the system should do i.e. provide telemetry dashboard to customers
  - Usually defined by system analyst
- Understand the non-functional requirements
  - Define technical and service level attributes i.e. # of users, loads, volumes of data, performance
  - Not always know to client or analyst
- Map the Components
  - Represent the tasks of the system
  - Two goals
    - helps to understand system functionality
    - communicate your understanding to the client
  - Non-technical (demonstrates capabilities of system only)
- Select the Technology Stack
  - Usually for backend, frontend, data stores
  - A lot of factors come into play so choose wisely
- Design the architecture
- Write the architecture document
  - Describes process and architecture i.e. blueprint
  - Must be relevant for all participants
- Support the team
  - Architecture will change a lot
  - Make sure it will stay relevant
  - Not done until system in production and need to maintain after
- Important to learn about unknown scenarios early
- Built together with development team and helps to grow ambassadors to convince others that architecture is right approach

Understanding Requirements

- Two types of requirements
  - What system should do = Functional Requirements
    - Business flows i.e. login, managing photos, telemetry
    - Business services i.e. auth, telemetry
    - User Interfaces
  - What should system deal with = non-functional requirements
    - Performance
    - Load
    - Data volume
    - Concurrent Users
    - SLA
  - Non-functional requirements
    - Performance
      - Always talk in numbers and work with client
      - What is fast? Typically less than sec for end user, for B2B usually less than 100ms
      - Latency: How much time does it take to perform a single task?
        - How much time will it take for the API to save the user data in the database?
        - How much time will it take to read a single file from the file system?
      - Throughput: How many tasks can be performed in a given time unit?
        - How many users can be saved in the database in a minute?
        - How many files can be read in a second?
      - Example case for saving user data
        - Latency less than 1 second
        - Throughput greater than 1000 in 1 minute for well designed app, less than 60 in 1 minute for badly designed app
    - Load
      - Quantity of work without crashing i.e. in web API how many concurrent requests without crashing
      - Defines availability of system
      - Example case: throughput of 100 requests/sec and load of 500 requests without crashing
        - Always plan for extreme cases
    - Data Volume
      - How much data the system will accumulate over time i.e. TB/GB
      - Helps with deciding
        - Database type
        - Designing queries (thousands of rows to millions of rows)
        - Storage planning
      - Two aspects
        - Data required on "Day One"
        - Data growth
      - Example day one 500 MB and annual growth of 2 TB
    - Concurrent users
      - How many users will be using the system simultaneously
      - Concurrent users includes "dead times" vs. actual requests with load
      - Concurrent users = Load x 10 for rule of thumb
    - SLA (Service level agreement)
      - Required uptime for the system (used by public providers)
      - 99.99% = less than 1 hour of downtime in a year (0.88 hrs downtime / year)
      - Manage client's expectations; 99.999% uptime is not a realistic goal (needs automatic failover, multi-region, etc)
    - Never start working before setting these non-functional requirements
    - Architect's roles
      - Framing the requirements' boundaries (100% uptime is not realistic, What is the required response time for API? 10ms); clients won't be able to define them
      - Discuss numbers

Application Types

- Web Apps
  - Websites, Web server, web browser, communicate via HTTP protocol
  - Browser sends HTTP request to server asking for resource i.e. HTML page, renders to end user with JS for implementation and CSS for visual design
  - Best suited for
    - User interface
    - User initiated actions
    - Large scale
    - Short, focused actions (not good fit to crunch billions of numbers)
  - Request-response based
- Web API
  - Clients are other applications/servers
  - Exposes an API for other programs to execute various actions
  - Usually REST API
    - Returns data (usually as JSON), not HTML
    - Accessible
  - Combination of
    - URL i.e. https://myapi.com/orders
    - Parameters i.e. date=10/10/2021
    - HTTP Verb i.e. GET
  - Best suited for systems that require
    - Data retrieval and store
    - Client initiated actions
    - Large scale
    - Short, focused actions (not long running processes)
  - Request-response based
- Mobile
  - Smartphones/mobile phones - Android or Apple
  - Usually works with Web API
  - Best suited for
    - User interation (games, social apps)
    - Frontend for Web API (news)
    - Location-sensitive for GPS
- Console
  - Command-line applications aka CLI in the terminal
  - No fancy UI
  - Require Technical Knowledge
  - Limited interaction
  - Long- or short-running processes
  - Best suited for systems that require
    - Long-running processes
    - Short actions by trained power-users
- Service
  - Like Console but no UI at all, managed by Service Manager in operating system i.e. Windows, Linux (monitors activity)
  - Config files
  - Best suited for systems that require
    - Long-running processes (i.e. monitoring folders and processing files)
- Desktop
  - Has all its resources on the PC
  - Might connect to the web
  - Has UI
  - Best suited for
    - User centric actions i.e. word processing
    - Gaming
- Function as a service
  - AWS Lambda
  - Azure functions
  - Short focused code segments and not worry about servers/SLAs
- Application type should be set early, can be more than one i.e. Web App + Service, Web App + Mobile

Selecting Technology Stack

- Important because often irreversible, emotional
- Decision must be made with clear mind, heavily documented, group effort
- Considerations
  - Can perform the task
  - Community (large, active, support) - can see stackoverflow posts/tags
  - Popularity (google trends search terms, github library repos)
- Backend and service technology
  - Web apps, web API, console, service
  - Focus on pros/cons
  - Candidates
    - .NET Classic (Microsoft)
      - Founded in 2001 by Microsoft
      - General purpose
      - Object oriented
      - Statically typed
      - IDE - Visual Studio
      - Windows only
      - Performance okay
      - Mature
      - Blurred roadmap
    - .NET Core
      - .NET vNext
      - Cross Platform
      - Great performance
      - Mature enough
      - IDE - Visual Studio, VS Code
      - Vocal, growing community
    - Java
      - Founded in 1995 by Sun Microsystems
      - Popular
      - General purpose
      - Object oriented
      - Statically typed
      - Huge community
    - node.js
      - Founded in 2009 by Ryan Dahl
      - Optimized for highly-concurrent web apps
      - Javascript-based
      - Dynamically typed
      - Large community
      - Great performance
    - PHP
      - Founded in 1994 by Rasmus Lerdorf
      - Little messy
      - Easy to learn
      - Not polished
      - Large community
      - Focused on web apps and web API
    - Python
      - Founded in 1989 by Guido van Rossum
      - Scripting language
      - Popular
      - Easy to learn
      - Huge, supportive community
      - Supports any type of application
    - Go
- Frontend technologies
  - App types
    - Web apps
      - HTML, CSS, and JavaScript
      - Which JavaScript framework?
        - React
          - UI-Centric library focusing on view/components
          - Short learning curve
        - Vue
        - Angular
          - Full-blown framework
          - Data binding, state management, routing
          - Long learning curve
    - Mobile
      - Native
        - iOS - Objective C or Swift with X-Code and iOS SDK
        - Android - Java with Android Studio and Android SDK
        - Full control, no limits with phone's features
        - Exceptional user experience
      - Hybrid
        - Thin wrapper around HTML, JavaScript, CSS
        - Very limited phone capabilities
        - Inferior user experience, graphics performance limited
        - PWA - progressive web apps can behave more like native apps
      - Cross-platform
        - Xamarin (C#, Visual Studio)
        - React Native (JavaScript)
        - Compile app to native forms, write code once
        - Catch-up with latest versions for phone features
        - Good with limitations on user experience
        - May still use native programming for some features
      - Tradeoffs between dev time and capabilities
    - Desktop
      - WinForms
        - Founded in 2001
        - Limited UI Flexibility
        - Short learning curve
        - Runs on PCs
      - WPF
        - Founded in 2006
        - Unlimited UI Flexibility
        - Long learning curve
        - Runs on PCs
      - UWP
        - Founded in 2015
        - Unlimited, but runs in sandbox
        - Long learning curve, less mature than WPF
        - Runs on PCs, XBOX, IoT
      - Electron
        - Built with JS
        - Slower performance
        - Can compile to be compatible with Windows or Mac
  - Data Store Technology
    - SQL
      - MySQL, Oracle, Microsoft SQL Server, PostgreSQL
      - Stores data in tables
      - Tables have concrete set of columns
      - Relationships aka relation i.e. Order and OrderItem tables
      - Transactions - atomic set of actions (all or nothing)
        - ACID:
          - Atomicity
          - Consistency
          - Isolation
          - Durability
      - Querying using SQL (Structured Query Language)
        - Mature for querying and modifying data
      - If data is not huge and you have structured data; data consistency important - can go SQL
    - NoSQL
      - Emphasis on scale and performance
      - Often distributed on many servers and can be large
      - MongoDB (has ACID transaction support though compared to others)
      - Schema-less
      - Data usually stored in JSON format/documents
      - Transactions
        - Eventual Consistency - guarantees action will be performed but doesn't guarantee when
        - Data can be temporarily inconsistent
        - Varies based on database
      - Querying
        - No standard for accessing data (has own language/driver), can be frustrating
    - If huge, un/semi-structured data, can use NoSQL

Introduction to the \*-ilities

- Quality attributes defining application's capabilities
- Technical capabilities that should be used in order to fulfill the non-functional requirements
- Example non-functional requirement: The system must work under heavy load but should not waste money on unused resources
  - Required quality attribute: scalability
- Non-functional requirements (what the system should deal with) map to quality attributes designed in the architecture
- \*ilities such as Scalability, Manageability, Modularity, Extensibility, Testability
- Scalability
  - Adding computing resources without any interruption
  - Non-scalable system
    - Non-scalable code
    - Rewrite non-scalable code
    - Reinforce VM for more CPU and memory
    - Long, cumbersome process to address these issues
  - Scalable system
    - Add VM for more CPU/memory
    - Notify the load balancer about new VM
    - Minimal to no changes to code
  - Scalability Types
    - Scale up = more CPU/memory on one VM, limits for one server
    - Scale out = more servers, redundancy, no limits
    - Opt for scaling out with a load balancer to distribute load across VMs
- Manageability
  - Know what's going on and take actions accordingly
  - VM provides report status to monitoring agent when load is high, goes to management console for decision to be made by human
  - Is your system manageable?
    - Who reports the problems?
      - Engineers = not manageable
      - System itself reports problems = much better, amount of requests seen and if performance degrades - can add more VMs to address issue
  - Modularity
    - A system that is built from building blocks that can be changed or replaced without affecting the whole system
    - External system with API, Our system gets the data and saves the data and talks to database
      - Everything coupled together and would require deploy across all dependent systems
    - If modular, code that accesses API and gets data is in its own piece; can deploy that part on its own and be more maintainable
  - Extensibility
    - A system that its functionality can be extended without modifying its existing code
    - API to query data with query parameter like format=XML|JSON; can add new format like CSV easily; can use factory method for getting formatter rather than switch statements to modify the code less
  - Testability
    - How easy it is to test the application
    - Types of testing
      - Manual
      - Unit Testing
        - Arrange, act, assert
        - Smallest unit/method we are testing
      - Integration Testing
        - Testing a module
    - Easy to test using unit and integration testing
    - Independent modules and methods
    - Single responsibility

Software Components Architecture

- Component/Service: Piece of code that runs in a single process
- Distributed systems:
  - Composed of independent software components
  - Deployed on separate processes or containers or servers
- Two Levels of Software Architecture
  - Component's Architecture
    - Inner components
    - Interaction between them
    - Make code fast and easy to maintain
  - System Architecture
    - Bigger picture
    - Scalable, reliable, fast, easy to maintain
- Layers
  - Represent horizontal functionality
  - Component Layers
    - UI or Service Interface (SI): expose functionality through user interface or API
      - Expose API
      - JSON Handling
      - Auth
    - Business Logic (BL): execute logic on data received from user
      - Validation
      - Enrichment
      - Computations
    - Data Access Layer (DAL): save and retrieve data
      - Connection handling
      - Querying / saving data
      - Transaction handling
  - Purpose of layers
    - Forces well formed and focused code
    - Modular
  - Concepts of Layers
    - Code Flow
      - A layer can only call one layer underneath i.e. UI/SI to BL but not to DAL
      - DAL layer can't call layer above like BL
    - Loose coupling
      - Want minimum impact when there is a change
      - Using dependency injection can help with this communication
    - Exception handling
      - DAL receives MySQLException from MySQL database so its inner workings should not bubble up to Business Logic layer
      - DAL should analyze exception, write to log, and throw generic exception such as DataException so Business Logic doesn't have to know exact MySQLException
    - Layers vs. Tiers
      - Layers in component/service: UI/SI - Business Logic - Data Access Layer, share computing resource
      - Tiers - deployed independently and talk to other tiers through network such as HTTP; 3 tiers = 3 independent components and talk to each other over the network
- Interface
  - Contract that declares signatures of an implementation
  - Allows us to make our code loosely coupled, not tying one class to another; prefer interfaces to direct references to classes
  - "New is Glue" often leads to closed tie and less flexible/modular
    - Using interface to define what a thing should do but doesn't show the implementation i.e. doing ICalculator calc = GetInstance();
- Dependency Injection
  - Technique whereby one object supplies the dependencies of another object
  - Implementation #1 factory method returning one class always
  - Implementation #2 switch case returning different classes
  - Implementation #3 using config value to return certain class
  - Constructor injection - receives instantiated interface objects and assign to this
    - helps with testing and can pass in mock object matching interface
- SOLID
  - Coined by Bob Martin in 2000
  - Single responsibility principle
    - Each class, module, or method should have one and only one responsibility; single well-defined functionality
    - Logging engine
      - What should be written? XML/JSON - composes message
      - Where should it be written? Often sent to a file database or event log - sending message over
    - Changes affect only a well defined module with the right encapsulation
  - Open/Closed principle
    - Software entity open for extension and closed for modification
    - Can be implemented using
      - Class inheritance
      - Plug-in mechanism
    - Make our code as flexible as possible
  - Liskov Substitution principle
    - If S is a subtype of T, then objects of type T may be replaced with objects of type S without altering any of the desired properties of the program
    - Behavioral subtyping and behavior should not change when changing class subtypes (looks similar to polymorphism)
    - Avoid unmaintainable code
  - Interface Segregation principle
    - many client-specific interfaces are better than one general-purpose interface
  - Dependency inversion principle
    - Dependency injection
- Naming Conventions
  - Define naming rules of code elements
    - Classes, Methods, Variables, Constants, etc.
    - Make the code more readable and easy to understand
    - Not enforced by compilers
    - Two types:
      - Structure (casing, underscores, etc.)
      - Content (what kind of words to be used in the name)
  - camelCase
    - first letter of second word onward will be capitalized
    - popular in Java, C#, JavaScript, Swift
    - recommended for class names in Python, Ruby
  - lowercase_separated_by_underscore (snake_case)
    - name contains only lowercase letters
    - words separated by underscore
    - popular in Python/Ruby for naming variables
  - CAPITALIZED_WITH_UNDERSCORE
    - popular in Java, Python, and Ruby for naming constants
  - Hungarian Notation
    - type information is part of the name i.e. string strFirstName
    - not popular and should be avoided (older strategy)
  - Class names should be nouns i.e. DataRetriever, Car, Network
  - Method names should be imperative verbs i.e. retrieveData, drive, sendPacket
  - Always decide on convention and stick to a standard, do it ASAP, folow it
- Exception Handling
  - Catch exception only if you have something to do with it
    - Logging does not count
    - Examples of when to catch:
      - Rolling back a transaction
      - Retry
      - Wrap the exception
  - Catch only specific exceptions
    - Example: SQLException when working with databases
    - Make sure you handle the right exception
  - Use try...catch on the smallest code fragments possible
    - Locate code fragments that may raise exceptions and try...catch on them (don't do it over large chunks of code)
- Logging
  - Two purposes
    - Track errors and exceptions, write them out to logs with relevant details like stack trace, user information, etc.
    - Gather data
      - Find out which module is most visited and which is less popular
      - Performance
      - User's flow
  - Log storage
    - Files
    - Database
    - Event log
    - Example: Kibana

Introduction to Design Patterns

- Collection of general, reusable solutions to common problems in software design
  - Examples include
    - How to communicate between classes
    - How to initialize interface implementations
    - How to access data stores
  - Tested and used by other developers
  - Makes code more readable and easy to modify
  - Introduced in 1987, popularized in Design Patterns Gang of Four book
  - Patterns are micro-architecture, should always be familiar with code
  - Some patterns
    - Factory
    - Repository
    - Facade
    - Command
- Factory Pattern
  - Creating objects without specifying the exact class of the object
  - Avoid strong coupling between classes
  - Example: Weather application needing to replace new instantiations (new is glue)
    - Can create an interface with same function signatures; have classes implement the interfaces
    - Create factory method that returns provider implementation of the interface
    - No longer using new directly for a specific class, code doesn't know which concrete class it's using
    - Can easily change the code in factory method
    - Can expand to multiple continents and switch cases to return an instance based on continent
  - Popular and base for other patterns, use it to avoid strong coupling
- Repository Pattern
  - Modules not handling the actual work with the datastore should be oblivious to the datastore type
  - Describes data abstraction technique to achieve isolation
  - Share similarities with data access layers (DAL is for architects)
  - Repository pattern for developers
  - Example: human resources application accessing datastore for CRUD operations
    - Read by ID and by department name
    - Before adding sql queries directly in functions but is error-prone for changes
    - Calls a factory method and gets an instance of the repository (represents data store) and exposes actions to talk with datastore (not accesssing datastore directly)
    - GetEmployeeById, GetEmployeesByDepartment, UpdateEmployee, CreateEmployee, DeleteEmployee in Repository; calling code doesn't know how it's implemented but makes it more flexible and easier to maintain
  - Helps with data store change if we move away from MySQL to some other database
    - Create new class implementing repository interface and switch them out i.e. SQLServerRepository to MongoDBRepository
  - Advanced forms include generic classes, inheritance, extension frameworks
- Facade Pattern
  - Creating a layer of abstraction to mask complex actions
  - Example: banking application which allows user to transfer money, make sure accounts exist, make sure frist account has enough money, withdraw money from first account, deposity money in second account, add event in account log -> bundle into one transfermoney function
  - Packages existing functionality into an easy to use method; makes code more readable and easier to use
- Command Pattern
  - All the action's information is encapsulated within an object
  - Example: undo mechanism in google docs; bad to have one large Undo class for each function you want to be able to undo
    - Each command can have execute function in ICommand interface
    - Define command classes i.e. DeleteWord, ChangeFont which implement the interface
    - Get reference to relevant objects
    - Implement the interface i.e. Execute() involves Command Object and Receiver i.e. the document
    - Undo mechanism involves queue of commands (Invoker) to enqueue to add to undo queue or dequeue and execute to perform undo

Introduction to System Architecture

- Take a look at the big picture
- Answers the questions
  - How will the system work under heavy load?
  - What will happen if the system will crash at this exact moment in the business flow?
  - How complicated can be the update process?
- Includes
  - Defining the software components (services)
  - Defining the way these components communicate
  - Designing the system's capabilities (scalability, redundancy, performance, etc)
- Loose Coupling
  - Making sure the services are not strongly tied to other services
  - When service A changes, it affects other services using/communicating with them
  - Want to be able to modify service A and make it flexible, easy to maintain
  - Prevents platform coupling
  - Prevents URL coupling i.e. changes in API endpoint path
  - Example: Portfolio service queries Stock Quotes Service (Java) exposed as Java RMI; Portfolio service needs to be implemented in Java to talk to Java RMI
    - Better one: Stock Quotes Service written in Java exposes a REST API and the recommendation service built in Python queries the stock service through REST API calls but if URL/REST API server changes, it'll lead to breaking changes
    - What happens if a single service changes its URL? Look at the spiderweb to see if your services are strongly coupled
    - Can build a `Yellow Pages` service that other services can query for the URL in case a service's URL changes
      - Services only need to know the Directory's URL such as Consul
    - Can also build a middle man or `Gateway` - maps tasks to URLs of the proper services
      - Calling service doesn't know the underlying services but it asks the gateway; services only need to know the gateway's URL
- Stateless
  - application's state is stored in only two places - the data store and the user interface; no state stored in application code
    - state = application's data
  - Example: User interface interacts with login service which checks database if user exists and retrieves user details
    - Data stored in code = stateful if stores user details in the login service and is bad
  - Scalability = ability to grow and shrink as needed
    - Scale up vs. scale out; scale out is usually preferred
  - Redundancy = allows system to function properly when resource is not working
    - System with more than one server
    - When server goes down, the other continues working
  - Scalable and redundant architecture
    - User interface talks to load balancer to distribute load between 3 login services which all talk to the database
      - Routes to live services only
      - Load balancer pings is alive/healthchecks to the servers
    - Best practice to use at least 3 instances
  - Stateful system has problems with scalability and redundancy
    - If server store details but load balancer routes to other server without the stored details, user would get errors
    - Should rely on the database for stored user details rather than the server storing data in a stateful way
    - If a server goes down, subsequent requests go to a different server and things should still work if it refers to the database always
  - Always use stateless architecture to support scalability and redundancy
- Caching
  - bring data closer to its consumer so that its retrieval will be faster
  - Example: browser cache serving page from browser's memory to display the page faster
    - Service needs data from database, has a data access layer to issue SQL statements to retrieve data
    - Database compiles the SQL, retrieves the data
    - Service DAL serializes to objects
    - Can use cache in between data store and data access layer, stores data in memory such as Redis
    - Tradeoff
      - Database (single source of truth) has high reliability as data is saved to disk and good performance as data is retrieved from disk, then serialized
      - Cache has poor reliability as data is stored in memory (lost in case of server crash) and excellent performance as data is retrieved from memory
  - What to cache?
    - Cache should hold data that is frequently accessed and rarely modified
      - retrieval should be fast and easy for optimal user experience and minimum load
      - using cache retrieval is fast since in-memory and UX is optimal
      - Syncing cache and database is a challenge; when not in sync, leads to data corruption and bad user experience
    - Examples: stock quotes service has cache in between database
      - Stock data changes frequently though
      - 3 servers with load balancer in front of them; each server with its own cache between database
      - Cache on one server updated but other server caches have stale data = bad
      - if we use in-memory, in-process cache, we'll need to develop sync mechanism and hammer the database - adding more load
      - if we use distributed cache, data immediately synced with all nodes and all servers have the same data
    - Cache types
      - in-memory, in-process cache; part of service's code and uses service's memory as part of process
        - Existing libraries
        - Can be easily implemented using static concurrent collection
        - Great performance
        - Size is limited to process's memory ~ few GBs
        - can store anything
      - distributed cache
        - external product
        - data is stored in separate process
        - provides interface for accessing data
        - size virtually unlimited
        - auto nodes syncing
        - 1 server updates cache and distributed to all other nodes so all in sync when other services talk to the distributed cache
        - not the best performance
        - stores only primitive types i.e. strings, numbers - needs more serializing/deserializing
  - Choosing Cache Type
    - Distributed Cache when
      - Distribution among servers
      - Failover capabilities
      - Large cache storage
      - Requires training and setup
    - In-memory, in-process cache
      - Best performance possible
      - Store complex objects
      - Easy to use
- Messaging
  - Means of communication between the various services (remember the spiderweb between services)
  - Not just REST API for communication between services
  - Not exclusive
  - Messaging Criteria
    - Performance - fast
    - Message Size - large/small
    - Execution Model - request response model or long running processes
    - Feedback and reliability - ability to determine if message failed and to perform corrective action
    - Complexity
  - REST API
    - de-facto standard for HTTP-based systems
    - service exposes HTTP API i.e. GET endpoint, POST endpoint
    - performance - very fast
    - message size - same as HTTP protocol limitations (usually get -> 8KB, post and put -> dozens MB)
    - execution model - request/response; great for quick, short actions but not suitable for long processes
    - feedback and reliability - immediate feedback via response codes i.e. 500 error, 400 error, 200 success
    - complexity - extremely easy to implement, serializing JSON, converting to objects (Java Spring, Python Flask, Node Express)
    - useful for - traditional web apps
  - HTTP Push notifications
    - Publish subscribe; client subscribes to service and service notifies client
    - Real-time communication: SignalR or Socket.io
    - Uses advanced web techniques like Web Sockets to allow bi-directional communication and keeping connection open between client and service
    - Popular in chats
    - Performance - excellent, fast with huge scale
    - Message Size - limited, usually no more than a few KB
    - Execution Model - Web socket connection / long polling (subscribed to event for long time, message executed on client)
    - Feedback and reliability - None (fire and forget), can be implemented, quite complex; if message not received due to network problems or bug, server would not know about it; not great for high reliability but mainly for client/server applications like chat app if message was missed
    - Complexity - extremely easy to implement
    - Useful for - chat, monitoring
  - Queue
    - Service places message in queue engine like RabbitMQ or MQSeries, Kafka; another service pulls message from queue
    - Messages will be handled once and only once
    - Messages will be handled in order (not always case for REST API)
    - Performance - not so good, push/poll, DB persistence
    - Message Size - technically almost not limited but use small messages
    - Execution model - polling (periodically polly queue for a new message to retrieve and handle)
    - Feedback and reliability - very reliable
    - Complexity - requires training and setup for queue engine, difficult to maintain
    - Useful for - complex system with lots of data, when order and reliability are top priority over performance
  - File-based and database-based
    - Place message as file in folder or record in database
    - Other service pulls message from folder or database
    - Performance - not so good, push/poll, db persistence
    - Message size - unlimited
    - Execution Model - polling
    - Feedback and reliability - very reliable
    - Complexity - requires training and setup
    - Useful for - complex systems with lots of data, better use queues
    - No guarantee of handling things once and in the right order
    - Problems with file locked and duplicate processing if we have multiple service instances
- Logging and Monitoring
  - Central logging service better than each service with its own log engine and with its own formats i.e. files, MySQL, NoSQL
  - All services can write logs to central logging service backed by a database for easier querying in one place
  - Implementation
    - Expose API to write logs to
    - Watch folders for log files and collects them i.e. LogStash
  - Logs of entire system in same format and accessible in one place
  - Correlation ID
    - Business flows may involve more than one service; need to find out which log record belongs to which flow when things fail
    - Identifier passed along the flow to track from start to finish i.e. guuid, created from beginning of flow and included in every log record to understand where and why
- Make right choices as early as possible and use these concepts to design a fast, secure, reliable, and easy to maintain system; not exclusive

Additional Considerations

- Deadline - be aware of impact on project's schedule
  - Example: Choosing Queue vs REST API for messaging
  - Consult with team leader regarding developers' capabilities
- Developers' Skillset - selecting unknown technologies might result in
  - Delay
  - Low Quality
- Migrations
  - .NET to Java = Not too difficult
  - Windows Desktop to Python Backend = very complicated
- IT Support
  - Queue engines, business flow managers, NoSQL databases need support (shouldn't require so much developer support)
  - Analyze effort needed to support, someone who is not a developer can take care of it
- Cost
  - Must be considered for buy vs. build
    - Rule of thumb: use an existing tool
    - but always estimate cost vs. value
  - Cost management can make or break a project

## Object-Oriented Programming SOLID Principles

`S - Single-Responsibility Principle`

Loose coupling and more cohesion, focus on modules doing one thing

`O - Open-closed Principle`

Open for extension, closed for modification

`L - Liskov Substitution Principle`

Every subclass/derived class should be substitutable for their base or parent class

`I - Interface Segregation Principle`

Client shouldn't be forced to implement interface it doesn't use or forced to depend on methods they don't use (shouldn't be any empty methods)

`D - Dependency Inversion Principle`

Entities depend on abstractions, not on concretions
High-level modules must not depend on low-level module but on abstractions
Promote decoupling, dependency injection may help
Invert the arrows of dependencies

## Become an Awesome Software Architect Book 1 Foundation

`What is software architecture?`

Series of decisions intended to reduce cost of building and changing your software

`Software Architect Hit List`

- Programming languages, features, readability, and interoperation
- Code reuse across platforms (server vs. web. vs. mobile)
- Early error detection (compile-time vs. runtime error detection, breadth of validation)
- Availability and cost of hiring the right talent; learning curve for new hires
- Readability and refactorability of code
- Approach to code composition, embracing the change
- Datastore and general approach to data modeling
- Application-specific data model, and blast radius from changing it
- Performance and latency in all tiers and platforms
- Scalability and redundancy
- Spiky traffic patterns, autoscaling, capacity planning
- Error recovery
- Logging, telemetry, and other instrumentation
- Reducing complexity
- User interfaces and their maintainability
- External APIs
- User identity and security
- Hardware and human costs of infrastructure and its maintenance
- Enabling multiple concurrent development workstreams
- Enabling testability
- Fast-tracking development by adopting third-party frameworks
- Personal: Deployment i.e. CICD
- Personal: Automating commands, steps, deployment, etc.
- Personal: Alerting when things go wrong

`Programming Languages`

- Can have favorite programming language but keep it personal only
- Logic/tradeoffs considered for tooling
- Characteristics of importance
  - Strong static typing
    - Languages generally divided by strong vs. weak typing and static vs. dynamic checking
    - Imposes strict restrictions on intermixing values of different data types to catch/prevent bugs
    - Static type checking checks at compile time without running the code (TypeScript) vs. dynamic checking for errors at runtime (JavaScript and Python)
    - Reliable code with strong typing and static type checking
  - Support for explicitly defined data structures
    - Ability to define data structure and validate compliance of objects you create against the declaration at compile time
    - Takes shape of interfaces or classes and better to check objects at compile time
    - In statically typed languages increases velocity and reliability; improved even more by IDE
