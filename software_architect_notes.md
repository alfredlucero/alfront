# Software Architect Notes

## What is a Software Architect?

Types of Architects

- Infrastructure Architect
  - Design infrastructure i.e. servers, vms, network, storage, etc.
  - Familiar with requirements
  - Career path: infrastructure expert
- Software Architect
  - Developer knows what can be done
  - Architect knows what should be done
  - Figures out how to meet these common baseline requirements:
    - Fast
    - Secure
    - Reliable
    - Easy to maintain
  - Org chart
    - junior architect may be within a project under project manager
    - senior architect may report directly to CIO/CTO outside of a specific project to handle things across the whole organization
    - certifications geared towards Enterprise Architect
  - Career path: main factor is experience
    - 3 years experience, more common in small companies
    - dev to team leader to jr. architect
    - dev to team leader to dev manager/CTO to senior architect (can become enterprise architect)
    - system analyst to architect but lacks technical experience and requires mentoring
- Enterprise Architect
  - Works with top level management i.e. CEO, CIO
  - Streamlines IT to support business
  - No development-oriented tasks
  - Career Path: Senior Software Architect / Project Manager

Architect's Mindset

- Understand the business
  - Weaknesses
  - Strengths
  - Competition
  - Growth Strategy
- System's Goals
  - Not "what the system should do" or requirements
  - Goals describe the effect on the organization (bottom line, big picture)
  - Usually described by client but exceptions
  - Example 1: Product-oriented company wants to streamline recruitment process in its HR system
  - Example 2: Improve police's response time, attract new residents for reporting and mapping criminal incidents system for large city
  - Example 3: Mobile flash sales for young and small startup, wants to generate quick revenue stream and attract investors
- Your Client's Clients (end users)
  - Possibly show errors or have backend caching if systems go down to provide best experience to users
- Always keep in mind what is the thing that really matters to the person you are talking to
  - Project manager cares primarily on project success (be careful with how you speak about new technology)
  - Team leader cares about programming (can use technical language)
  - CEO cares about the financial bottom line, can avoid technical buzzwords
  - Show how your work contributes to the other person's primary interests

Architecture Process

- Understand the system's requirements after setting the goals
  - Requirements = what the system should do i.e. provide telemetry dashboard to customers
  - Usually defined by system analyst
- Understand the non-functional requirements
  - Define technical and service level attributes i.e. # of users, loads, volumes of data, performance
  - Not always know to client or analyst
- Map the Components
  - Represent the tasks of the system
  - Two goals
    - helps to understand system functionality
    - communicate your understanding to the client
  - Non-technical (demonstrates capabilities of system only)
- Select the Technology Stack
  - Usually for backend, frontend, data stores
  - A lot of factors come into play so choose wisely
- Design the architecture
- Write the architecture document
  - Describes process and architecture i.e. blueprint
  - Must be relevant for all participants
- Support the team
  - Architecture will change a lot
  - Make sure it will stay relevant
  - Not done until system in production and need to maintain after
- Important to learn about unknown scenarios early
- Built together with development team and helps to grow ambassadors to convince others that architecture is right approach

Understanding Requirements

- Two types of requirements
  - What system should do = Functional Requirements
    - Business flows i.e. login, managing photos, telemetry
    - Business services i.e. auth, telemetry
    - User Interfaces
  - What should system deal with = non-functional requirements
    - Performance
    - Load
    - Data volume
    - Concurrent Users
    - SLA
  - Non-functional requirements
    - Performance
      - Always talk in numbers and work with client
      - What is fast? Typically less than sec for end user, for B2B usually less than 100ms
      - Latency: How much time does it take to perform a single task?
        - How much time will it take for the API to save the user data in the database?
        - How much time will it take to read a single file from the file system?
      - Throughput: How many tasks can be performed in a given time unit?
        - How many users can be saved in the database in a minute?
        - How many files can be read in a second?
      - Example case for saving user data
        - Latency less than 1 second
        - Throughput greater than 1000 in 1 minute for well designed app, less than 60 in 1 minute for badly designed app
    - Load
      - Quantity of work without crashing i.e. in web API how many concurrent requests without crashing
      - Defines availability of system
      - Example case: throughput of 100 requests/sec and load of 500 requests without crashing
        - Always plan for extreme cases
    - Data Volume
      - How much data the system will accumulate over time i.e. TB/GB
      - Helps with deciding
        - Database type
        - Designing queries (thousands of rows to millions of rows)
        - Storage planning
      - Two aspects
        - Data required on "Day One"
        - Data growth
      - Example day one 500 MB and annual growth of 2 TB
    - Concurrent users
      - How many users will be using the system simultaneously
      - Concurrent users includes "dead times" vs. actual requests with load
      - Concurrent users = Load x 10 for rule of thumb
    - SLA (Service level agreement)
      - Required uptime for the system (used by public providers)
      - 99.99% = less than 1 hour of downtime in a year (0.88 hrs downtime / year)
      - Manage client's expectations; 99.999% uptime is not a realistic goal (needs automatic failover, multi-region, etc)
    - Never start working before setting these non-functional requirements
    - Architect's roles
      - Framing the requirements' boundaries (100% uptime is not realistic, What is the required response time for API? 10ms); clients won't be able to define them
      - Discuss numbers

Application Types

- Web Apps
  - Websites, Web server, web browser, communicate via HTTP protocol
  - Browser sends HTTP request to server asking for resource i.e. HTML page, renders to end user with JS for implementation and CSS for visual design
  - Best suited for
    - User interface
    - User initiated actions
    - Large scale
    - Short, focused actions (not good fit to crunch billions of numbers)
  - Request-response based
- Web API
  - Clients are other applications/servers
  - Exposes an API for other programs to execute various actions
  - Usually REST API
    - Returns data (usually as JSON), not HTML
    - Accessible
  - Combination of
    - URL i.e. https://myapi.com/orders
    - Parameters i.e. date=10/10/2021
    - HTTP Verb i.e. GET
  - Best suited for systems that require
    - Data retrieval and store
    - Client initiated actions
    - Large scale
    - Short, focused actions (not long running processes)
  - Request-response based
- Mobile
  - Smartphones/mobile phones - Android or Apple
  - Usually works with Web API
  - Best suited for
    - User interation (games, social apps)
    - Frontend for Web API (news)
    - Location-sensitive for GPS
- Console
  - Command-line applications aka CLI in the terminal
  - No fancy UI
  - Require Technical Knowledge
  - Limited interaction
  - Long- or short-running processes
  - Best suited for systems that require
    - Long-running processes
    - Short actions by trained power-users
- Service
  - Like Console but no UI at all, managed by Service Manager in operating system i.e. Windows, Linux (monitors activity)
  - Config files
  - Best suited for systems that require
    - Long-running processes (i.e. monitoring folders and processing files)
- Desktop
  - Has all its resources on the PC
  - Might connect to the web
  - Has UI
  - Best suited for
    - User centric actions i.e. word processing
    - Gaming
- Function as a service
  - AWS Lambda
  - Azure functions
  - Short focused code segments and not worry about servers/SLAs
- Application type should be set early, can be more than one i.e. Web App + Service, Web App + Mobile

Selecting Technology Stack

- Important because often irreversible, emotional
- Decision must be made with clear mind, heavily documented, group effort
- Considerations
  - Can perform the task
  - Community (large, active, support) - can see stackoverflow posts/tags
  - Popularity (google trends search terms, github library repos)
- Backend and service technology
  - Web apps, web API, console, service
  - Focus on pros/cons
  - Candidates
    - .NET Classic (Microsoft)
      - Founded in 2001 by Microsoft
      - General purpose
      - Object oriented
      - Statically typed
      - IDE - Visual Studio
      - Windows only
      - Performance okay
      - Mature
      - Blurred roadmap
    - .NET Core
      - .NET vNext
      - Cross Platform
      - Great performance
      - Mature enough
      - IDE - Visual Studio, VS Code
      - Vocal, growing community
    - Java
      - Founded in 1995 by Sun Microsystems
      - Popular
      - General purpose
      - Object oriented
      - Statically typed
      - Huge community
    - node.js
      - Founded in 2009 by Ryan Dahl
      - Optimized for highly-concurrent web apps
      - Javascript-based
      - Dynamically typed
      - Large community
      - Great performance
    - PHP
      - Founded in 1994 by Rasmus Lerdorf
      - Little messy
      - Easy to learn
      - Not polished
      - Large community
      - Focused on web apps and web API
    - Python
      - Founded in 1989 by Guido van Rossum
      - Scripting language
      - Popular
      - Easy to learn
      - Huge, supportive community
      - Supports any type of application
    - Go
- Frontend technologies
  - App types
    - Web apps
      - HTML, CSS, and JavaScript
      - Which JavaScript framework?
        - React
          - UI-Centric library focusing on view/components
          - Short learning curve
        - Vue
        - Angular
          - Full-blown framework
          - Data binding, state management, routing
          - Long learning curve
    - Mobile
      - Native
        - iOS - Objective C or Swift with X-Code and iOS SDK
        - Android - Java with Android Studio and Android SDK
        - Full control, no limits with phone's features
        - Exceptional user experience
      - Hybrid
        - Thin wrapper around HTML, JavaScript, CSS
        - Very limited phone capabilities
        - Inferior user experience, graphics performance limited
        - PWA - progressive web apps can behave more like native apps
      - Cross-platform
        - Xamarin (C#, Visual Studio)
        - React Native (JavaScript)
        - Compile app to native forms, write code once
        - Catch-up with latest versions for phone features
        - Good with limitations on user experience
        - May still use native programming for some features
      - Tradeoffs between dev time and capabilities
    - Desktop
      - WinForms
        - Founded in 2001
        - Limited UI Flexibility
        - Short learning curve
        - Runs on PCs
      - WPF
        - Founded in 2006
        - Unlimited UI Flexibility
        - Long learning curve
        - Runs on PCs
      - UWP
        - Founded in 2015
        - Unlimited, but runs in sandbox
        - Long learning curve, less mature than WPF
        - Runs on PCs, XBOX, IoT
      - Electron
        - Built with JS
        - Slower performance
        - Can compile to be compatible with Windows or Mac
  - Data Store Technology
    - SQL
      - MySQL, Oracle, Microsoft SQL Server, PostgreSQL
      - Stores data in tables
      - Tables have concrete set of columns
      - Relationships aka relation i.e. Order and OrderItem tables
      - Transactions - atomic set of actions (all or nothing)
        - ACID:
          - Atomicity
          - Consistency
          - Isolation
          - Durability
      - Querying using SQL (Structured Query Language)
        - Mature for querying and modifying data
      - If data is not huge and you have structured data; data consistency important - can go SQL
    - NoSQL
      - Emphasis on scale and performance
      - Often distributed on many servers and can be large
      - MongoDB (has ACID transaction support though compared to others)
      - Schema-less
      - Data usually stored in JSON format/documents
      - Transactions
        - Eventual Consistency - guarantees action will be performed but doesn't guarantee when
        - Data can be temporarily inconsistent
        - Varies based on database
      - Querying
        - No standard for accessing data (has own language/driver), can be frustrating
    - If huge, un/semi-structured data, can use NoSQL

Introduction to the \*-ilities

- Quality attributes defining application's capabilities
- Technical capabilities that should be used in order to fulfill the non-functional requirements
- Example non-functional requirement: The system must work under heavy load but should not waste money on unused resources
  - Required quality attribute: scalability
- Non-functional requirements (what the system should deal with) map to quality attributes designed in the architecture
- \*ilities such as Scalability, Manageability, Modularity, Extensibility, Testability
- Scalability
  - Adding computing resources without any interruption
  - Non-scalable system
    - Non-scalable code
    - Rewrite non-scalable code
    - Reinforce VM for more CPU and memory
    - Long, cumbersome process to address these issues
  - Scalable system
    - Add VM for more CPU/memory
    - Notify the load balancer about new VM
    - Minimal to no changes to code
  - Scalability Types
    - Scale up = more CPU/memory on one VM, limits for one server
    - Scale out = more servers, redundancy, no limits
    - Opt for scaling out with a load balancer to distribute load across VMs
- Manageability
  - Know what's going on and take actions accordingly
  - VM provides report status to monitoring agent when load is high, goes to management console for decision to be made by human
  - Is your system manageable?
    - Who reports the problems?
      - Engineers = not manageable
      - System itself reports problems = much better, amount of requests seen and if performance degrades - can add more VMs to address issue
  - Modularity
    - A system that is built from building blocks that can be changed or replaced without affecting the whole system
    - External system with API, Our system gets the data and saves the data and talks to database
      - Everything coupled together and would require deploy across all dependent systems
    - If modular, code that accesses API and gets data is in its own piece; can deploy that part on its own and be more maintainable
  - Extensibility
    - A system that its functionality can be extended without modifying its existing code
    - API to query data with query parameter like format=XML|JSON; can add new format like CSV easily; can use factory method for getting formatter rather than switch statements to modify the code less
  - Testability
    - How easy it is to test the application
    - Types of testing
      - Manual
      - Unit Testing
        - Arrange, act, assert
        - Smallest unit/method we are testing
      - Integration Testing
        - Testing a module
    - Easy to test using unit and integration testing
    - Independent modules and methods
    - Single responsibility

Software Components Architecture

- Component/Service: Piece of code that runs in a single process
- Distributed systems:
  - Composed of independent software components
  - Deployed on separate processes or containers or servers
- Two Levels of Software Architecture
  - Component's Architecture
    - Inner components
    - Interaction between them
    - Make code fast and easy to maintain
  - System Architecture
    - Bigger picture
    - Scalable, reliable, fast, easy to maintain
- Layers
  - Represent horizontal functionality
  - Component Layers
    - UI or Service Interface (SI): expose functionality through user interface or API
      - Expose API
      - JSON Handling
      - Auth
    - Business Logic (BL): execute logic on data received from user
      - Validation
      - Enrichment
      - Computations
    - Data Access Layer (DAL): save and retrieve data
      - Connection handling
      - Querying / saving data
      - Transaction handling
  - Purpose of layers
    - Forces well formed and focused code
    - Modular
  - Concepts of Layers
    - Code Flow
      - A layer can only call one layer underneath i.e. UI/SI to BL but not to DAL
      - DAL layer can't call layer above like BL
    - Loose coupling
      - Want minimum impact when there is a change
      - Using dependency injection can help with this communication
    - Exception handling
      - DAL receives MySQLException from MySQL database so its inner workings should not bubble up to Business Logic layer
      - DAL should analyze exception, write to log, and throw generic exception such as DataException so Business Logic doesn't have to know exact MySQLException
    - Layers vs. Tiers
      - Layers in component/service: UI/SI - Business Logic - Data Access Layer, share computing resource
      - Tiers - deployed independently and talk to other tiers through network such as HTTP; 3 tiers = 3 independent components and talk to each other over the network
- Interface
  - Contract that declares signatures of an implementation
  - Allows us to make our code loosely coupled, not tying one class to another; prefer interfaces to direct references to classes
  - "New is Glue" often leads to closed tie and less flexible/modular
    - Using interface to define what a thing should do but doesn't show the implementation i.e. doing ICalculator calc = GetInstance();
- Dependency Injection
  - Technique whereby one object supplies the dependencies of another object
  - Implementation #1 factory method returning one class always
  - Implementation #2 switch case returning different classes
  - Implementation #3 using config value to return certain class
  - Constructor injection - receives instantiated interface objects and assign to this
    - helps with testing and can pass in mock object matching interface
- SOLID
  - Coined by Bob Martin in 2000
  - Single responsibility principle
    - Each class, module, or method should have one and only one responsibility; single well-defined functionality
    - Logging engine
      - What should be written? XML/JSON - composes message
      - Where should it be written? Often sent to a file database or event log - sending message over
    - Changes affect only a well defined module with the right encapsulation
  - Open/Closed principle
    - Software entity open for extension and closed for modification
    - Can be implemented using
      - Class inheritance
      - Plug-in mechanism
    - Make our code as flexible as possible
  - Liskov Substitution principle
    - If S is a subtype of T, then objects of type T may be replaced with objects of type S without altering any of the desired properties of the program
    - Behavioral subtyping and behavior should not change when changing class subtypes (looks similar to polymorphism)
    - Avoid unmaintainable code
  - Interface Segregation principle
    - many client-specific interfaces are better than one general-purpose interface
  - Dependency inversion principle
    - Dependency injection
- Naming Conventions
  - Define naming rules of code elements
    - Classes, Methods, Variables, Constants, etc.
    - Make the code more readable and easy to understand
    - Not enforced by compilers
    - Two types:
      - Structure (casing, underscores, etc.)
      - Content (what kind of words to be used in the name)
  - camelCase
    - first letter of second word onward will be capitalized
    - popular in Java, C#, JavaScript, Swift
    - recommended for class names in Python, Ruby
  - lowercase_separated_by_underscore (snake_case)
    - name contains only lowercase letters
    - words separated by underscore
    - popular in Python/Ruby for naming variables
  - CAPITALIZED_WITH_UNDERSCORE
    - popular in Java, Python, and Ruby for naming constants
  - Hungarian Notation
    - type information is part of the name i.e. string strFirstName
    - not popular and should be avoided (older strategy)
  - Class names should be nouns i.e. DataRetriever, Car, Network
  - Method names should be imperative verbs i.e. retrieveData, drive, sendPacket
  - Always decide on convention and stick to a standard, do it ASAP, folow it
- Exception Handling
  - Catch exception only if you have something to do with it
    - Logging does not count
    - Examples of when to catch:
      - Rolling back a transaction
      - Retry
      - Wrap the exception
  - Catch only specific exceptions
    - Example: SQLException when working with databases
    - Make sure you handle the right exception
  - Use try...catch on the smallest code fragments possible
    - Locate code fragments that may raise exceptions and try...catch on them (don't do it over large chunks of code)
- Logging
  - Two purposes
    - Track errors and exceptions, write them out to logs with relevant details like stack trace, user information, etc.
    - Gather data
      - Find out which module is most visited and which is less popular
      - Performance
      - User's flow
  - Log storage
    - Files
    - Database
    - Event log
    - Example: Kibana

Introduction to Design Patterns

- Collection of general, reusable solutions to common problems in software design
  - Examples include
    - How to communicate between classes
    - How to initialize interface implementations
    - How to access data stores
  - Tested and used by other developers
  - Makes code more readable and easy to modify
  - Introduced in 1987, popularized in Design Patterns Gang of Four book
  - Patterns are micro-architecture, should always be familiar with code
  - Some patterns
    - Factory
    - Repository
    - Facade
    - Command
- Factory Pattern
  - Creating objects without specifying the exact class of the object
  - Avoid strong coupling between classes
  - Example: Weather application needing to replace new instantiations (new is glue)
    - Can create an interface with same function signatures; have classes implement the interfaces
    - Create factory method that returns provider implementation of the interface
    - No longer using new directly for a specific class, code doesn't know which concrete class it's using
    - Can easily change the code in factory method
    - Can expand to multiple continents and switch cases to return an instance based on continent
  - Popular and base for other patterns, use it to avoid strong coupling
- Repository Pattern
  - Modules not handling the actual work with the datastore should be oblivious to the datastore type
  - Describes data abstraction technique to achieve isolation
  - Share similarities with data access layers (DAL is for architects)
  - Repository pattern for developers
  - Example: human resources application accessing datastore for CRUD operations
    - Read by ID and by department name
    - Before adding sql queries directly in functions but is error-prone for changes
    - Calls a factory method and gets an instance of the repository (represents data store) and exposes actions to talk with datastore (not accesssing datastore directly)
    - GetEmployeeById, GetEmployeesByDepartment, UpdateEmployee, CreateEmployee, DeleteEmployee in Repository; calling code doesn't know how it's implemented but makes it more flexible and easier to maintain
  - Helps with data store change if we move away from MySQL to some other database
    - Create new class implementing repository interface and switch them out i.e. SQLServerRepository to MongoDBRepository
  - Advanced forms include generic classes, inheritance, extension frameworks
- Facade Pattern
  - Creating a layer of abstraction to mask complex actions
  - Example: banking application which allows user to transfer money, make sure accounts exist, make sure frist account has enough money, withdraw money from first account, deposity money in second account, add event in account log -> bundle into one transfermoney function
  - Packages existing functionality into an easy to use method; makes code more readable and easier to use
- Command Pattern
  - All the action's information is encapsulated within an object
  - Example: undo mechanism in google docs; bad to have one large Undo class for each function you want to be able to undo
    - Each command can have execute function in ICommand interface
    - Define command classes i.e. DeleteWord, ChangeFont which implement the interface
    - Get reference to relevant objects
    - Implement the interface i.e. Execute() involves Command Object and Receiver i.e. the document
    - Undo mechanism involves queue of commands (Invoker) to enqueue to add to undo queue or dequeue and execute to perform undo

Introduction to System Architecture

- Take a look at the big picture
- Answers the questions
  - How will the system work under heavy load?
  - What will happen if the system will crash at this exact moment in the business flow?
  - How complicated can be the update process?
- Includes
  - Defining the software components (services)
  - Defining the way these components communicate
  - Designing the system's capabilities (scalability, redundancy, performance, etc)
- Loose Coupling
  - Making sure the services are not strongly tied to other services
  - When service A changes, it affects other services using/communicating with them
  - Want to be able to modify service A and make it flexible, easy to maintain
  - Prevents platform coupling
  - Prevents URL coupling i.e. changes in API endpoint path
  - Example: Portfolio service queries Stock Quotes Service (Java) exposed as Java RMI; Portfolio service needs to be implemented in Java to talk to Java RMI
    - Better one: Stock Quotes Service written in Java exposes a REST API and the recommendation service built in Python queries the stock service through REST API calls but if URL/REST API server changes, it'll lead to breaking changes
    - What happens if a single service changes its URL? Look at the spiderweb to see if your services are strongly coupled
    - Can build a `Yellow Pages` service that other services can query for the URL in case a service's URL changes
      - Services only need to know the Directory's URL such as Consul
    - Can also build a middle man or `Gateway` - maps tasks to URLs of the proper services
      - Calling service doesn't know the underlying services but it asks the gateway; services only need to know the gateway's URL
- Stateless
  - application's state is stored in only two places - the data store and the user interface; no state stored in application code
    - state = application's data
  - Example: User interface interacts with login service which checks database if user exists and retrieves user details
    - Data stored in code = stateful if stores user details in the login service and is bad
  - Scalability = ability to grow and shrink as needed
    - Scale up vs. scale out; scale out is usually preferred
  - Redundancy = allows system to function properly when resource is not working
    - System with more than one server
    - When server goes down, the other continues working
  - Scalable and redundant architecture
    - User interface talks to load balancer to distribute load between 3 login services which all talk to the database
      - Routes to live services only
      - Load balancer pings is alive/healthchecks to the servers
    - Best practice to use at least 3 instances
  - Stateful system has problems with scalability and redundancy
    - If server store details but load balancer routes to other server without the stored details, user would get errors
    - Should rely on the database for stored user details rather than the server storing data in a stateful way
    - If a server goes down, subsequent requests go to a different server and things should still work if it refers to the database always
  - Always use stateless architecture to support scalability and redundancy
- Caching
  - bring data closer to its consumer so that its retrieval will be faster
  - Example: browser cache serving page from browser's memory to display the page faster
    - Service needs data from database, has a data access layer to issue SQL statements to retrieve data
    - Database compiles the SQL, retrieves the data
    - Service DAL serializes to objects
    - Can use cache in between data store and data access layer, stores data in memory such as Redis
    - Tradeoff
      - Database (single source of truth) has high reliability as data is saved to disk and good performance as data is retrieved from disk, then serialized
      - Cache has poor reliability as data is stored in memory (lost in case of server crash) and excellent performance as data is retrieved from memory
  - What to cache?
    - Cache should hold data that is frequently accessed and rarely modified
      - retrieval should be fast and easy for optimal user experience and minimum load
      - using cache retrieval is fast since in-memory and UX is optimal
      - Syncing cache and database is a challenge; when not in sync, leads to data corruption and bad user experience
    - Examples: stock quotes service has cache in between database
      - Stock data changes frequently though
      - 3 servers with load balancer in front of them; each server with its own cache between database
      - Cache on one server updated but other server caches have stale data = bad
      - if we use in-memory, in-process cache, we'll need to develop sync mechanism and hammer the database - adding more load
      - if we use distributed cache, data immediately synced with all nodes and all servers have the same data
    - Cache types
      - in-memory, in-process cache; part of service's code and uses service's memory as part of process
        - Existing libraries
        - Can be easily implemented using static concurrent collection
        - Great performance
        - Size is limited to process's memory ~ few GBs
        - can store anything
      - distributed cache
        - external product
        - data is stored in separate process
        - provides interface for accessing data
        - size virtually unlimited
        - auto nodes syncing
        - 1 server updates cache and distributed to all other nodes so all in sync when other services talk to the distributed cache
        - not the best performance
        - stores only primitive types i.e. strings, numbers - needs more serializing/deserializing
  - Choosing Cache Type
    - Distributed Cache when
      - Distribution among servers
      - Failover capabilities
      - Large cache storage
      - Requires training and setup
    - In-memory, in-process cache
      - Best performance possible
      - Store complex objects
      - Easy to use
- Messaging
  - Means of communication between the various services (remember the spiderweb between services)
  - Not just REST API for communication between services
  - Not exclusive
  - Messaging Criteria
    - Performance - fast
    - Message Size - large/small
    - Execution Model - request response model or long running processes
    - Feedback and reliability - ability to determine if message failed and to perform corrective action
    - Complexity
  - REST API
    - de-facto standard for HTTP-based systems
    - service exposes HTTP API i.e. GET endpoint, POST endpoint
    - performance - very fast
    - message size - same as HTTP protocol limitations (usually get -> 8KB, post and put -> dozens MB)
    - execution model - request/response; great for quick, short actions but not suitable for long processes
    - feedback and reliability - immediate feedback via response codes i.e. 500 error, 400 error, 200 success
    - complexity - extremely easy to implement, serializing JSON, converting to objects (Java Spring, Python Flask, Node Express)
    - useful for - traditional web apps
  - HTTP Push notifications
    - Publish subscribe; client subscribes to service and service notifies client
    - Real-time communication: SignalR or Socket.io
    - Uses advanced web techniques like Web Sockets to allow bi-directional communication and keeping connection open between client and service
    - Popular in chats
    - Performance - excellent, fast with huge scale
    - Message Size - limited, usually no more than a few KB
    - Execution Model - Web socket connection / long polling (subscribed to event for long time, message executed on client)
    - Feedback and reliability - None (fire and forget), can be implemented, quite complex; if message not received due to network problems or bug, server would not know about it; not great for high reliability but mainly for client/server applications like chat app if message was missed
    - Complexity - extremely easy to implement
    - Useful for - chat, monitoring
  - Queue
    - Service places message in queue engine like RabbitMQ or MQSeries, Kafka; another service pulls message from queue
    - Messages will be handled once and only once
    - Messages will be handled in order (not always case for REST API)
    - Performance - not so good, push/poll, DB persistence
    - Message Size - technically almost not limited but use small messages
    - Execution model - polling (periodically polly queue for a new message to retrieve and handle)
    - Feedback and reliability - very reliable
    - Complexity - requires training and setup for queue engine, difficult to maintain
    - Useful for - complex system with lots of data, when order and reliability are top priority over performance
  - File-based and database-based
    - Place message as file in folder or record in database
    - Other service pulls message from folder or database
    - Performance - not so good, push/poll, db persistence
    - Message size - unlimited
    - Execution Model - polling
    - Feedback and reliability - very reliable
    - Complexity - requires training and setup
    - Useful for - complex systems with lots of data, better use queues
    - No guarantee of handling things once and in the right order
    - Problems with file locked and duplicate processing if we have multiple service instances
- Logging and Monitoring
  - Central logging service better than each service with its own log engine and with its own formats i.e. files, MySQL, NoSQL
  - All services can write logs to central logging service backed by a database for easier querying in one place
  - Implementation
    - Expose API to write logs to
    - Watch folders for log files and collects them i.e. LogStash
  - Logs of entire system in same format and accessible in one place
  - Correlation ID
    - Business flows may involve more than one service; need to find out which log record belongs to which flow when things fail
    - Identifier passed along the flow to track from start to finish i.e. guuid, created from beginning of flow and included in every log record to understand where and why
- Make right choices as early as possible and use these concepts to design a fast, secure, reliable, and easy to maintain system; not exclusive

Additional Considerations

- Deadline - be aware of impact on project's schedule
  - Example: Choosing Queue vs REST API for messaging
  - Consult with team leader regarding developers' capabilities
- Developers' Skillset - selecting unknown technologies might result in
  - Delay
  - Low Quality
- Migrations
  - .NET to Java = Not too difficult
  - Windows Desktop to Python Backend = very complicated
- IT Support
  - Queue engines, business flow managers, NoSQL databases need support (shouldn't require so much developer support)
  - Analyze effort needed to support, someone who is not a developer can take care of it
- Cost
  - Must be considered for buy vs. build
    - Rule of thumb: use an existing tool
    - but always estimate cost vs. value
  - Cost management can make or break a project

Architecture Document

- Contains the architecture, functional and non-functional requirements, technology stack
- No development before document
- Goal of architecture document
  - Describe what should be developed and how
  - Lay out the requirements (functional and non-functional)
- Audience
  - Almost everyone involved - project manager, CTO, QA leader, developers
  - Development team
    - Concerned about technology stack, components, services, communication, etc.
  - Management
    - Project manager, CTO, CEO to ensure "project is in good hands", requirements reflect the essence of the system
    - Executive summary describes best practices and modern patterns
    - Architecture geared towards business goals
  - QA lead
    - Prepare testing infrastructure i.e integration and load testing
    - Servers, testing tools configured, coding involved
- Contents/format of the document
  - Standards such as UML aka modeling language
    - Visualizes system's design
    - Consists of concepts and diagrams
    - Audience is usually not familiar with it and requires a lot of time for explaining
  - Recommended format
    - As simple as possible with plain English, get into the minds of the readers
    - Visualize using software you're comfortable with i.e. powerpoint, images, charting tools, etc.
  - Structure
    - Background
      - Less than 1 page
      - Audience = team and management
      - Describes system from business point of view
        - System's role
        - Reasons for replacing old system
        - Expected business impact
      - Validates your point of view and boosts confidence in you from others
    - Requirements
      - Less than one page
      - Audience = team and management
      - Functional requirements = what the system should do
      - Non-functional requirements = what should the system deal with i.e. performance, load, data volume, SLA, and more
      - Brief, bulleted list 
      - Validate your understanding of requirements
      - Requirements dictate architecture
      - Structure
        - First - outline functional requirements
        - Second - outline non-functional requirements and be accurate and specific
    - Executive Summary 
      - Less than 3 pages
      - Audience = management (project managers, qas, non-developers, ctos, etc.) 
      - Goal: High level overview of solution since management is busy and non-technical and boost confidence in your work; get into your readers' mind
      - Tips: use charts and diagrams, write it after writing the rest of the document, use well known technical terms sparsely, don't repeat yourself
    - Architecture Overview
      - Less than 10 pages
      - Audience = development team and QA lead
      - Provides high-level view of the architecture and presents it to the team
      - No deep-dive to specific components
      - General description of design
        - Type i.e. web-based, micro services, REST API
        - Major NF-Requirements i.e. 50 Reqs/Sec
      - High-level diagram
        - No formal visualization standard i.e. datastores as cylinders, arrows for communication, boxes for services; logic diagram displaying components
      - Diagram walkthrough
        - Describe various parts and their role
        - Uses simple words
        - Includes all relevant details
      - Technology Stack
        - Is it a single stack? If yes put it here; if no, put it in each component's drilldown
    - Components Drill-down
      - Length is unlimited, longest section
      - Audience = development team and qa lead
      - For each component
        - Component's role
          - Recap of component's description from architecture overview section
        - Technology Stack
          - Technologies used to develop component
          - Lay out datastore, backend, frontend
          - Be extremely detailed and include rationale behind choice
          - Sample table comparision: NoSQL
            - Working schema-less
            - Developers have experience
            - Easy to implement
            - Performance
          - SQL Relational
          -   Better support for complex querying
          -   IT has experience supporting it
      - Component's architecture
        - Inner architecture of the component
        - Describe the API
          - Include method names i.e. for REST API - include URL, role, response code, comments
        - Describe the layers and include important considerations (dependency injection, etc.), be as detailed as possible
      - Development Instructions
        - Specific development guidelines
    - Center of architect's work and must include all insights
  
Case Study of Real World Application

- IOToo - IOT Controlled for Internet of things, small connected devices we use everyday like connected thermostats
- Dashboard that reports status of devices client is using i.e. smart thermostat, fridge, router, cameras, light bulbs; unified view of all devices on the scren
- Collects status information from registered devices and displays metrics on dashboard; queries about devices as well
  - Phase 1: Read only and data is presented to customer
    - Customers pre-registered by Sales through intensive verification process; devices already registered manually
- Defining the Requirements
  - Functional (what system should do)
    - Receive status updates from IOT devices
    - Store the updates for future use
    - Query the updates
  - Non-Functional (what system should deal with)
    - Messages received from IOT devices and should expect a lot of messages as it affects the load (how many concurrent messages expected) and data volume (datastore issues)
    - How many concurrent messages should the system expect in peak time? 500 messages
    - What is the total number of messages per month? 15,000,000
    - What is the average size of a message? 300 bytes
    - 15,000,000 messages/month * 300 bytes = 4500mb per month * 12 months = 54gb => expected data volume is 54gb annually; assume data retention policy is infinite for this application and data won't expire
    - Load: 500 concurrent messages
    - Message Loss: how tolerant are we to losing data due to network problems or errors
      - When single message is lost, not as big a deal since a new update will provide new message anyways, not big customer impact - can do 99% accuracy; 100% is not as realistic and harder to achieve when things do down
    - Users
      - How many users will the system have? Expect more devices than users - 2,000,000 users
      - How many concurrent users should we expect? 40 concurrent users
        - Number of users actively accessing the server at the same time
    - Load: 540 concurrent requests since 500 concurrent messages and 40 concurrent users
    - SLA
      - What is the maximum downtime allowed? 100% uptime is not realistic as hardware, virtualization, network, database servers may have unexpected issues
      - SLA Software Level
        - Platinum = fully stateless, easily scaled out, logging and monitoring, reliable and redundant
        - Gold
        - Silver
    - Recap of Non-functional requirements
      - Data Volume: 54GB annually
      - Load: 540 concurrent requests
      - 1% Message Loss
      - 2,000,000 Users
      - SLA: Platinum
- Mapping the Components
  - Look back at functional requirements - status updates from IOT devices, store updates for future use, query updates
  - Look back at non-functional requirements - 540 concurrent requests
  - Receiver Component
    - Heavy load of 540 concurrent requests, needs to be as fast as possible in processing messages and don't want thread starvation (not enough resources to handle waiting request and throwing exceptions)
    - Immediately insert to data store? Quite rare to do
    - Validate, process, store? Depends
    - Client says: 4 types of devices and formats, 3 use JSON, 1 uses fixed-format, validation is a must
    - Overall Tasks
      - Receive
      - Validate
      - Parse
        - Data is independent from source
        - Fully accessible
        - Extremely important when data is received from multiple sources to be able to query things in same way
      - Save
    - Since we have a heavy load and want to process message as fast as possible, Receiver will only receive the message
  - Handler Component
    - Handles validation, parsing, and storing
    - Talks to data store
  - Info Component - handles user's requests
    - Querying the data
    - Talks to data store
  - Logging Component
    - All logs sent to central logging service
  - Choosing Messaging Methods
    - Receiver receives messages from IOT devices - depends on how they send their data
      - Devices communicate via HTTP using POST verb to send update
      - REST API/HTTP
    - Handler
      - Handler talks to receiver through a queue for order and reliability
        - If we used REST API, it will cause a lot of work for the receiver as it'll have to wait for requests to finish
        - Queues are more fire and forget; receiver puts message into queue and forgets about it
    - Info
      - Accessed by end users who use web browsers which access servers using HTTP/REST API
    - Logging
      - Logs can be massive and can produce a lot of logs every hour
      - Using REST API? hurts performance badly
      - Files? Can aggregate its contents but not compatible with cloud, highly uncontrolled and can be deleted
      - Database? Can store there and query this
      - Queue? All services place logs in queue that logging component will interact with
      - Ensure IT supports/can maintain queue
- Logging Service
  - Read log records from queue (always on and running)
  - Validate records
  - Save in data store
  - Application Type = Service
    - Web app and web api - not appropriate since always online and can initiate things on its own
    - Mobile app - nope since not tied to mobile device
    - Console - long-running processes, potential
    - Service - No UI at all and managed by service manager, potential
    - Desktop app - nope
  - Technology Stack
    - Component's Code
      - Access queue's API
      - Store data in data store
      - Dev team is familiar with Microsoft stack like .NET and SQL Server - should use .NET Core more current and SQL Server database
      - Java/MySQL and Python/PostgreSQL also valid combos
      - Doesn't need a UI and doesn't expose API
    - Data Store - SQL Server
    - Polling layer (replaces UI/SI) for accessing queue and retrieving log records to be accessed by business logic and then data access layer to data store
      - Polls queue every few seconds for log records
    - Business logic layer
      - Validates records
    - Data Access layer
      - Saves records in data store
      - Can use Entity framework for ORM capabilities; representing database records as objects
    - Can do dependency injection using Microsoft.Extensions.DependencyInjection
- Receiver Service
  - Receives messages from IOT devices and sends messages to queue
  - Application type = Web API since exposes HTTP RESTAPI for devices to make POST calls to
  - Technology Stack
    - .Net Core has great support for Web API apps
  - Architecture
    - Service Interface
    - Business Logic
    - Data Access not required since we don't care about data store in this service -> replaced by Queue handler
    - Logging layer to log everything that happens during the receiving of the message: more vertical, cross-cutting concern, available to all layers to log what is going on
  - Non-functional requirements
    - Message loss: 1%
      - Yes, REST API is quite reliable, very low chance of errors in such a simple service
    - Load: 500 concurrent messages from devices
      - Yes, architecture is stateless
      - Easily scaled out as it adds message to a queue
      - Service is simple
- Handler Service
  - Validates, parses, and stores messages in data store
  - Messages wait in queue after being placed in there by the receiver
  - Application Type = Service (always active and busy polling the queue)
  - Technology Stack
    - .NET Core and SQL Server
  - Architecture
    - No UI/API layer exposed -> replaced by Polling
    - Business logic -> validating and parsing messages, plug-in mechanism is good idea for dynamically loading parses/validators based on message type
    - Data access -> save handled messages into the data store
    - Logging layer is vertical and accessible by all the layers
- Info Service
  - Allows end users to query the data; it doesn't display the data as the client can choose to display it custom
  - Application Type = Web App and Web API
  - Technology Stack
    - .NET Core
  - Architecture
    - Service Interface - need to define the REST API
      - Get current status of devices for specific device and entire house
      - Get past events devices
      - Required functionality
        - Get all the updates for a specific house's devices for a given time range
          - GET /api/houses/houseId/devices/updates?from=from&to=to -> 200 with house device updates; 404 if no matching house id
          - URL contains references to specific entities so that's why from/to go to query string paremeters (not entities)
        - Get updates for a specific device for a given time range
          - GET /api/devices/deviceId/updates?from=from&to=to -> 200/404
        - Get current status of all devices in a specific house
          - GET /api/houses/houseId/devices/status/current -> 200/404
        - Get current status of a specific device
          - GET /api/devices/deviceId/status/current -> 200/404
      - Two factors for API design:
        - API Path
        - Return code and contents
      - Retrieve device #17 = GET /api/devices/17 -> 200 with JSON response
    - Business logic
    - Data access to access database and retrieve data
    - Vertical logging layer

Advanced Architecture Patterns

- Microservices
  - An architecture in which various functionalities are implemented as separate, loosely coupled services that interact with each other using standard, lightweight protocol
  - Before applications would be built as a monolith with 3 layer architecture within a single process i.e. Service Interface, Business logic, data access -> data store
    - Example: Employees, Salary, Vacation stuff all intertwined for HR application
    - Problems
      - Single exception may crash the whole process
      - Updates impact all the components
      - Limited to one dev platform
      - Unoptimized compute resources
  - Each service runs in its own process and does not impact other services in case of exceptions
  - Each service can be updated separately and not coupled; can be updated more frequently
  - Each service can be implemented using different platform
  - Each service can be optimized separately i.e. one service on 4 VMs with 16 cores each vs. 2 VMs with 8 cores on another service
  - Split out HR service into 3 services: Employees, Salary, Vacation services
    - Layered architecture of service interface, business logic, data access -> data store
  - Drawbacks
    - Complex monitoring and can have lots of services; Netflix developed Eureka for monitoring
    - Complex architecture with distributed systems and can take time to design
    - Complex testing with multiple services to talk to; services depending on other services
- Event Sourcing
  - Entities stored in traditional database with attributes; instead we add events that happen to entity
  - Example: bank account statement; list of events happening to entity and we don't see entity itself
  - Use cases
    - Use when history matters; when you care how entity changed from creation to now
  - Pros
    - Tracing
    - Simple data model
    - Performance (Small record inserted to data store)
    - Reporting
  - Cons
    - No unified view of entity; tough to build current state of entity
    - Storage usage related to entities with large histories
- CQRS
  - Command Query Responsibility Segregation
  - Data Storage database and Data Retrieval database
  - Some service syncs them
  - Helps to solve the unified view problem with event sourcing
    - Events storage for quick update performance in database A, entities'current state retrieval in database B, sync service in between the two
  - Cons
    - Not as simple with 2 databases, sync service between storage and retrieval databases, event sourcing for storage database
  - Useful with high frequency updates that require near real-time query capabilities i.e. telemetry

Soft Skills

- Architect can't be arrogant/righteous and doesn't have as much authority; must be able to influence without authority
- Listening: collective wisdom is better; assume you aren't the smartest person in the room
- Dealing with criticism: don't attack back, be professional with facts and logic behind genuine questioning
  - Don't be afraid to say I'll check it again and review if you haven't considered something
  - Mocking you: don't get offended or attack back; be professional and provide facts/logic
  - Be smart, not right; goal: approve the architecture; what kind of response will help get the approval? show consideration and how you thought about the other perspective and ask to discuss offline to show respect; avoid a long technical discussion in the meeting
- Organizational politics: don't be part of the politics
- Public speaking
  - Define a clear goal
  - Know your audience
  - Be confident
  - Don't read
  - Maintain eye contact
- Learning
  - jQuery/AngularJS, hadoop, grunt more outdated; adapt/continue learning
  - Blogs: DZone, O'Reilly
  - Articles: InfoQ
  - Conferences: O'Reilly Software Architecture, build, QCon, NDC Conferences


## Object-Oriented Programming SOLID Principles

`S - Single-Responsibility Principle`

Loose coupling and more cohesion, focus on modules doing one thing

`O - Open-closed Principle`

Open for extension, closed for modification

`L - Liskov Substitution Principle`

Every subclass/derived class should be substitutable for their base or parent class

`I - Interface Segregation Principle`

Client shouldn't be forced to implement interface it doesn't use or forced to depend on methods they don't use (shouldn't be any empty methods)

`D - Dependency Inversion Principle`

Entities depend on abstractions, not on concretions
High-level modules must not depend on low-level module but on abstractions
Promote decoupling, dependency injection may help
Invert the arrows of dependencies

## Become an Awesome Software Architect Book 1 Foundation

`What is software architecture?`

Series of decisions intended to reduce cost of building and changing your software

`Software Architect Hit List`

- Programming languages, features, readability, and interoperation
- Code reuse across platforms (server vs. web. vs. mobile)
- Early error detection (compile-time vs. runtime error detection, breadth of validation)
- Availability and cost of hiring the right talent; learning curve for new hires
- Readability and refactorability of code
- Approach to code composition, embracing the change
- Datastore and general approach to data modeling
- Application-specific data model, and blast radius from changing it
- Performance and latency in all tiers and platforms
- Scalability and redundancy
- Spiky traffic patterns, autoscaling, capacity planning
- Error recovery
- Logging, telemetry, and other instrumentation
- Reducing complexity
- User interfaces and their maintainability
- External APIs
- User identity and security
- Hardware and human costs of infrastructure and its maintenance
- Enabling multiple concurrent development workstreams
- Enabling testability
- Fast-tracking development by adopting third-party frameworks
- Personal: Deployment i.e. CICD
- Personal: Automating commands, steps, deployment, etc.
- Personal: Alerting when things go wrong

`Programming Languages`

- Can have favorite programming language but keep it personal only
- Logic/tradeoffs considered for tooling
- Characteristics of importance
  - Strong static typing
    - Languages generally divided by strong vs. weak typing and static vs. dynamic checking
    - Imposes strict restrictions on intermixing values of different data types to catch/prevent bugs
    - Static type checking checks at compile time without running the code (TypeScript) vs. dynamic checking for errors at runtime (JavaScript and Python)
    - Reliable code with strong typing and static type checking
  - Support for explicitly defined data structures
    - Ability to define data structure and validate compliance of objects you create against the declaration at compile time
    - Takes shape of interfaces or classes and better to check objects at compile time
    - In statically typed languages increases velocity and reliability; improved even more by IDE
  - Support for interfaces 
    - Way to create an abstraction or contract for a data structure or class
    - Enable Dependency Injection design pattern or dependency inversion principle
    - If no interfaces supported, can use abstract classes to define contracts i.e. Python
  - Isomorphism
    - Language's ability to run across multiple platforms that underpin your solution i.e. running on client platform like browser or mobile device and on the server
    - Native isomorphism - works on all target platforms natively i.e. JavaScript in browser and on server
    - Transpiled isomorphism - not supported across all platforms natively but can be transpiled (cross-compiled) into another language which is natively isomorphic i.e. TypeScript transpiles into JavaScript used for browser, Node.js server or mobile apps with React Native or Apache Cordova; can use same third-party libraries across all platforms 
    - Generated isomorphism - language is not supportred across all platforms natively but there exists a tool that generates platform-specifc code in another language, independently for each platform i.e. Kotlin which can run natively on server in Java Virtual Machine or on Android devices but can generate JavaScript equivalent to run in browser
      - Weakest kind of isomorphism because code is portable but can't port third-party libraries you may need unless written in same language and supplied with source code
    - Native/transpiled isomorphism is usually good enough for cross-platform development projects for code sharing and third-party libraries across platforms; most popular native one is JavaScript
  - Availability of third-party libaries
    - i.e. NPM for JavaScript/TypeScript, Java, Python; don't have to write things yourself if module exists
  - Ease of refactoring
    - Refactoring means restructuring of existing code without changing its external behavior
      - Renaming data types, variables and members, moving members from one class to another, adding or removing parameter functions, converting methods to top-level functions, converting static members to global variables or constants, converting inner classes to top-level calsses, moving declarations and implementations between modules
    - Easier refactoring with compiled languages and strong static type checking; great IDE support like Eclipse
  - Functional vs. Object-oriented
    - Object-oriented programming (OOP) works with objects
      - Usually stateful, promotes encapsulation in objects (treat as black boxes)
      - Inheritance; implementing objects with similarities; interfaces with contracts for dependency injection pattern
    - Functional programming (FP)
      - Data and behaviors distinct and kept separate for clarity
      - Behaviors as black box and data as white box
      - Pure functions causing no side effects, stateless implementations of behaviors
